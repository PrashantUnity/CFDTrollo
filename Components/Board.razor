@using CFDTrollo.Models
@using CFDTrollo.Data
@using CFDTrollo.Services
@inject LocalStorageService LocalStorage
@inject IJSRuntime JSRuntime
@inject DragDropService DragDropService
@implements IDisposable

<div class="min-h-screen bg-board">
    <main class="p-6 md:p-8 overflow-x-auto">
        <div id="board-lists" class="flex gap-4 md:gap-6 items-start min-h-[200px] pb-4 w-max" @ref="boardListsElement">
            @foreach (var (list, index) in boardState.Lists.Select((list, index) => (list, index)))
            {
                <ListComponent List="@list" 
                               Index="@index" 
                               OnAddCard="@((title) => HandleAddCard(list.Id, title))" 
                               OnUpdateCard="@HandleUpdateCard" />
            }
        </div>
    </main>
    
    <!-- Horizontal line at bottom -->
    <div class="border-t border-border/50 mx-4"></div>

    <!-- Floating Add List Button - Bottom Right -->
    <button @onclick="HandleQuickAddList"
            class="fixed bottom-6 right-6 bg-primary hover:bg-primary/90 text-primary-foreground rounded-full p-4 shadow-lg hover:shadow-xl transition-all duration-200 flex items-center justify-center w-14 h-14 z-50"
            title="Add New List">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"></path>
        </svg>
    </button>
</div>

@code {
    [Parameter] public string WorkspaceId { get; set; } = "default";
    [Parameter] public EventCallback<int> OnCardCountChanged { get; set; }

    private BoardState boardState = new();
    private DotNetObjectReference<Board>? dotNetReference;
    private ElementReference boardListsElement;

    protected override async Task OnInitializedAsync()
    {
        await LoadBoardState();
        dotNetReference = DotNetObjectReference.Create(this);
        await DragDropService.InitializeDragDropAsync(dotNetReference);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await DragDropService.EnableListDropZoneAsync(boardListsElement);
        }
    }

    private async Task LoadBoardState()
    {
        var storageKey = GetStorageKey(WorkspaceId);
        var savedState = await LocalStorage.GetItem<BoardState>(storageKey);
        
        if (savedState != null && savedState.Lists.Any())
        {
            boardState = savedState;
        }
        else
        {
            boardState = InitialBoardState.GetInitialState();
        }
    }

    private async Task SaveBoardState()
    {
        if (boardState.Lists.Any())
        {
            var storageKey = GetStorageKey(WorkspaceId);
            await LocalStorage.SetItem(storageKey, boardState);
            await NotifyCardCountChanged();
        }
    }

    private async Task NotifyCardCountChanged()
    {
        var totalCards = boardState.Lists.Sum(list => list.Cards.Count);
        await OnCardCountChanged.InvokeAsync(totalCards);
    }

    private string GetStorageKey(string workspaceId) => $"project-board-state-{workspaceId}";

    private void HandleAddCard(string listId, string title)
    {
        var list = boardState.Lists.FirstOrDefault(l => l.Id == listId);
        if (list != null)
        {
            var newCard = new Card
            {
                Id = $"card-{DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()}",
                Title = title
            };
            list.Cards.Add(newCard);
            StateHasChanged();
            _ = SaveBoardState();
        }
    }

    private void HandleUpdateCard(Card updatedCard)
    {
        foreach (var list in boardState.Lists)
        {
            var cardIndex = list.Cards.FindIndex(c => c.Id == updatedCard.Id);
            if (cardIndex >= 0)
            {
                list.Cards[cardIndex] = updatedCard;
                break;
            }
        }
        StateHasChanged();
        _ = SaveBoardState();
    }

    private void HandleQuickAddList()
    {
        var newList = new List
        {
            Id = $"list-{DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()}",
            Title = $"New List {boardState.Lists.Count + 1}",
            Cards = new List<Card>()
        };

        boardState.Lists.Add(newList);
        StateHasChanged();
        _ = SaveBoardState();
    }

    [JSInvokable]
    public async Task HandleCardDrop(string cardId, string sourceListTitle, string targetListId, int dropIndex)
    {
        try
        {
            // Find source and target lists
            var sourceList = boardState.Lists.FirstOrDefault(l => l.Title == sourceListTitle);
            var targetList = boardState.Lists.FirstOrDefault(l => l.Id == targetListId);

            if (sourceList == null || targetList == null) return;

            // Find the card to move
            var card = sourceList.Cards.FirstOrDefault(c => c.Id == cardId);
            if (card == null) return;

            // Remove from source list
            sourceList.Cards.Remove(card);

            // Add to target list at the correct position
            if (dropIndex >= 0 && dropIndex < targetList.Cards.Count)
            {
                targetList.Cards.Insert(dropIndex, card);
            }
            else
            {
                targetList.Cards.Add(card);
            }

            StateHasChanged();
            await SaveBoardState();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error handling card drop: {ex.Message}");
        }
    }

    [JSInvokable]
    public async Task HandleListDrop(string listId, int dropIndex)
    {
        try
        {
            // Find the list to move
            var list = boardState.Lists.FirstOrDefault(l => l.Id == listId);
            if (list == null) return;

            // Get current index
            var currentIndex = boardState.Lists.IndexOf(list);
            if (currentIndex == -1) return;

            // Remove from current position
            boardState.Lists.RemoveAt(currentIndex);

            // Adjust drop index if needed
            if (currentIndex < dropIndex)
            {
                dropIndex--;
            }

            // Insert at new position
            if (dropIndex >= 0 && dropIndex < boardState.Lists.Count)
            {
                boardState.Lists.Insert(dropIndex, list);
            }
            else
            {
                boardState.Lists.Add(list);
            }

            StateHasChanged();
            await SaveBoardState();
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error handling list drop: {ex.Message}");
        }
    }

    public void Dispose()
    {
        dotNetReference?.Dispose();
    }
}
